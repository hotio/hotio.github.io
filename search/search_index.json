{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome","title":"Welcome","text":"<p>Go check out the rest of our website to see how you can get started with your favorite app. Most images come with docker cli or compose examples. If you've got any questions, feel free to join the discord server. Discord is our main channel to provide support, if you think to have found a bug in one of the images, feel free to create a new issue on GitHub.</p> <p>If you enjoy the images don't forget to go give us a star on Docker Hub and GitHub. It would mean a lot to us!</p>"},{"location":"#donations","title":"Donations","text":"<p>If you like what I do, you know the drill... </p> <p> GitHub Sponsors  Open Collective</p> <p> Bitcoin  Ethereum  Litecoin</p>"},{"location":"#support","title":"Support","text":"<p>Join us on Discord!</p> <p> </p>"},{"location":"faq/","title":"FAQ","text":"I'm here if you need me..."},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":"Someone asked you for a 'docker-compose' snippet...How do you give them that? <p>If you are not using <code>docker-compose</code>, that can sound like a daunting task. Have no fear though, the following cli command spits it out.</p> <pre><code>docker run --rm -v /var/run/docker.sock:/var/run/docker.sock:ro ghcr.io/red5d/docker-autocompose &lt;container-name-or-id&gt; [&lt;additional-names-or-ids&gt;]\n</code></pre> <p>Now you should upload this to logs.notifiarr.com after removing personal details and passwords.</p>"},{"location":"faq/#installation","title":"Installation","text":"Installing Docker, how and where? <p>I'd have a look at the official Docker Engine installation instructions.</p>"},{"location":"faq/#guides","title":"Guides","text":"I would like to execute my own scripts on startup, how would I do this? <p>This will only work for containers using <code>s6 overlay</code>, recognisable by <code>ENVIRONMENT</code> printed at the top of the log when the container starts.</p> <p>If you have a need to do additional stuff when the container starts or stops, you can mount your script with the volume <code>/docker/host/my-script.sh:/etc/cont-init.d/99-my-script</code> to execute your script on container start or <code>/docker/host/my-script.sh:/etc/cont-finish.d/99-my-script</code> to execute it when the container stops. An example script can be seen below.</p> <pre><code>#!/command/with-contenv bash\necho \"Hello, this is me, your script.\"\n</code></pre> How can I get a static IP for one of my containers using 'docker-compose'? <p>Here's a basic docker-compose example that sets up a custom network and gives the plex container a static IP.</p> <pre><code>version: \"3.7\"\n\nnetworks:\n  my-custom-network:\n    name: my-custom-network\n    driver: bridge\n    ipam:\n      driver: default\n      config:\n        - subnet: 10.1.0.0/24\n\nservices:\n  plex:\n    container_name: plex\n    image: hotio/plex\n    ports:\n      - \"32400:32400\"\n    networks:\n      my-custom-network:\n        ipv4_address: 10.1.0.100\n    ...\n\n  radarr:\n    container_name: radarr\n    image: hotio/radarr\n    ports:\n      - \"7878:7878\"\n    networks:\n      - my-custom-network\n    ...\n</code></pre> How do I route a container's traffic through a VPN container? <p>Small docker-compose example below. Notice the <code>...</code>, this isn't a copy/paste ready to go example.</p> <pre><code>version: \"3.7\"\n\nservices:\n  qbittorrent:\n    container_name: qbittorrent\n    image: hotio/qbittorrent\n    ports:\n      - \"8080:8080\"\n      - \"9117:9117\"\n    environment:\n      ...\n      - VPN_EXPOSE_PORTS_ON_LAN=9117/tcp,9117/udp\n    ...\n\n  jackett:\n    container_name: jackett\n    image: hotio/jackett\n    network_mode: \"service:qbittorrent\"\n    ...\n</code></pre> Got any Docker guides? <p>Take a look here for an extensive guide on best practises from the *arr team.</p> But, but, how do I configure all this stuff? <p>Maybe TRaSH from TRaSH Guides can help...</p>"},{"location":"containers/autoscan/","title":"hotio/autoscan","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/autoscan/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name autoscan \\\n    -p 3030:3030 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/autoscan\n</code></pre> <pre><code>services:\n  autoscan:\n    container_name: autoscan\n    image: ghcr.io/hotio/autoscan\n    ports:\n      - \"3030:3030\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/autoscan/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/autoscan/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/base/","title":"hotio/base","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/base/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name base \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/base:alpinevpn\n</code></pre> <pre><code>services:\n  base:\n    container_name: base\n    image: ghcr.io/hotio/base:alpinevpn\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre> <p>This image is the base image for all other application images, however it can be used as a standalone VPN image for other images to attach to.</p>"},{"location":"containers/base/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/base/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/bazarr/","title":"hotio/bazarr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/bazarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name bazarr \\\n    -p 6767:6767 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e WEBUI_PORTS=\"6767/tcp,6767/udp\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/bazarr\n</code></pre> <pre><code>services:\n  bazarr:\n    container_name: bazarr\n    image: ghcr.io/hotio/bazarr\n    ports:\n      - \"6767:6767\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=6767/tcp,6767/udp\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/bazarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/bazarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/caddy/","title":"hotio/caddy","text":"<p> GitHub docker.io /   ghcr.io</p> <p>What is this?</p> <p>A docker image with Caddy 2 (included modules: caddy-dns/cloudflare, mholt/caddy-ratelimit). The default config only allows access from private ip ranges.</p>"},{"location":"containers/caddy/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name caddy \\\n    -p 80:8080 \\\n    -p 443:8443 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e CUSTOM_BUILD=\"\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/caddy\n</code></pre> <pre><code>services:\n  caddy:\n    container_name: caddy\n    image: ghcr.io/hotio/caddy\n    ports:\n      - \"80:8080\"\n      - \"443:8443\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - CUSTOM_BUILD\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/caddy/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/caddy/#custom-build","title":"Custom build","text":"<p>If you set the environment variable <code>CUSTOM_BUILD</code> to a file location like for example <code>/config/caddy_linux_amd64_custom</code>, an attempt is made to start Caddy with that binary. The custom build can be obtained from the Caddy download page. This is particularly useful if you need extra modules.</p>"},{"location":"containers/caddy/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/cloudflareddns/","title":"hotio/cloudflareddns","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/cloudflareddns/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name cloudflareddns \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e INTERVAL=300 \\\n    -e DETECTION_MODE=\"dig-whoami.cloudflare\" \\\n    -e LOG_LEVEL=3 \\\n    -e CF_USER=\"your.cf.email@example.com\" \\\n    -e CF_APIKEY=\"your.global.apikey\" \\\n    -e CF_APITOKEN=\"\" \\\n    -e CF_APITOKEN_ZONE=\"\" \\\n    -e CF_HOSTS=\"test.example.com;test.foobar.com;test2.foobar.com\" \\\n    -e CF_ZONES=\"example.com;foobar.com;foobar.com\" \\\n    -e CF_RECORDTYPES=\"A;A;AAAA\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/cloudflareddns\n</code></pre> <pre><code>services:\n  cloudflareddns:\n    container_name: cloudflareddns\n    image: ghcr.io/hotio/cloudflareddns\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - INTERVAL=300\n      - DETECTION_MODE=dig-whoami.cloudflare\n      - LOG_LEVEL=3\n      - CF_USER=your.cf.email@example.com\n      - CF_APIKEY=your.global.apikey\n      - CF_APITOKEN\n      - CF_APITOKEN_ZONE\n      - CF_HOSTS=test.example.com;test.foobar.com;test2.foobar.com\n      - CF_ZONES=example.com;foobar.com;foobar.com\n      - CF_RECORDTYPES=A;A;AAAA\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre> <p>Possible values for <code>DETECTION_MODE</code> are <code>dig-google.com</code>, <code>dig-opendns.com</code>, <code>dig-whoami.cloudflare</code>, <code>curl-icanhazip.com</code>, <code>curl-wtfismyip.com</code>, <code>curl-showmyip.ca</code>, <code>curl-da.gd</code>, <code>curl-seeip.org</code>, <code>curl-ifconfig.co</code> and <code>curl-ipw.cn</code>. If you want to get the local ip from a network interface, use something like <code>local:eth0</code> as <code>DETECTION_MODE</code>.</p> <p>Notice that we give 3 values each time for <code>CF_HOSTS</code>, <code>CF_ZONES</code> and <code>CF_RECORDTYPES</code>. In our example, the domain <code>test.foobar.com</code> belonging to the zone <code>foobar.com</code> will have its A record updated with an ipv4 ip. If you use <code>CF_APITOKEN</code>, you can leave <code>CF_USER</code> and <code>CF_APIKEY</code> empty.</p> <p>Important</p> <p>All the domain names in <code>CF_HOSTS</code> should have properly configured DNS records on Cloudflare, they will not be created.</p>"},{"location":"containers/cloudflareddns/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/cloudflareddns/#zone-id","title":"Zone ID","text":"<p>Instead of the <code>zone_name</code>, you can also fill in a <code>zone_id</code> in <code>CF_ZONES</code>. When using a <code>zone_id</code>, you can use a scoped token (<code>CF_APITOKEN</code>) that only needs the <code>Zone - DNS - Edit</code> permissions. This improves security. The configuration could look like the example below.</p> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_HOSTS=\"example.com;test.foobar.com\"\n-e CF_ZONES=\"zbpsi9ceikrdnnym27s2xnp6s5dvj6ep;dccbe6grakumohwwd4amh4o46yupepn8\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre>"},{"location":"containers/cloudflareddns/#seperate-api-tokens","title":"Seperate API Tokens","text":"<p>If you do not prefer to use a <code>zone_id</code>, but prefer some more security, you can use 2 seperate tokens.</p> <p><code>CF_APITOKEN</code> configured with:</p> <p>Permissions <code>Zone - DNS - Edit</code> Zone Resources <code>Include - Specific zone - example.com</code> <code>Include - Specific zone - foobar.com</code></p> <p><code>CF_APITOKEN_ZONE</code> configured with:</p> <p>Permissions <code>Zone - Zone - Read</code> Zone Resources <code>Include - All zones</code></p> <p>Leaving <code>CF_APITOKEN_ZONE</code> blank would mean that only <code>CF_APITOKEN</code> will be used and thus that token should have all required permissions. Which usually means that the token could edit all zones or not be able to fetch the <code>zone_id</code> from the <code>zone_name</code>.</p>"},{"location":"containers/cloudflareddns/#configuration-combination-examples","title":"Configuration combination examples","text":"<p>Below are some example configuration combinations, ordered from most secure to least secure.</p> <ul> <li>We use a <code>zone_id</code> so that our token only needs the permissions <code>Zone - DNS - Edit</code>.</li> </ul> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"zbpsi9ceikrdnnym27s2xnp6s5dvj6ep;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre> <ul> <li>We use additionally a <code>CF_APITOKEN_ZONE</code> with the permissions <code>Zone - Zone - Read</code> to query the zones and getting the <code>zone_id</code>.</li> </ul> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_APITOKEN_ZONE=\"8m4TxzWb9QHXEpTwQDMugkKuHRavsxoK8qmJ4P7M\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"example.com;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre> <ul> <li>We use only <code>CF_APITOKEN</code>, but with the permissions <code>Zone - DNS - Edit</code> and <code>Zone - Zone - Read</code>.</li> </ul> <pre><code>-e CF_APITOKEN=\"azkqvJ86wEScojvSJC8DyY67TwqNwZCtomEVrHwt\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"example.com;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre> <ul> <li>We use <code>CF_USER</code> and <code>CF_APIKEY</code>, basically giving full control over our account.</li> </ul> <pre><code>-e CF_USER=\"your.cf.email@example.com\"\n-e CF_APIKEY=\"your.global.apikey\"\n-e CF_HOSTS=\"vpn.example.com;test.foobar.com\"\n-e CF_ZONES=\"example.com;axozor886pyja7nmbcvu5kh7dp9557j4\"\n-e CF_RECORDTYPES=\"A;A\"\n</code></pre>"},{"location":"containers/cloudflareddns/#example-of-the-log-output","title":"Example of the log output","text":"<pre><code>2020-05-17 17:20:54 -    INFO - IPv4 detected by [dig-whoami.cloudflare] is [1.1.1.1].\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Reading zone list from Cloudflare.\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Retrieved zone list from Cloudflare.\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Zone ID [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] found for zone [example.com].\n2020-05-17 17:20:54 -    INFO - [1/1] [A] [vpn.example.com] Reading DNS record from Cloudflare.\n2020-05-17 17:20:55 -    INFO - [1/1] [A] [vpn.example.com] Writing DNS record to cache file [/config/cf-ddns-A-vpn.example.com.cache].\n2020-05-17 17:20:55 -    INFO - [1/1] [A] [vpn.example.com] Checking if update is needed.\n2020-05-17 17:20:55 -    INFO - [1/1] [A] [vpn.example.com] No update needed.\n2020-05-17 17:20:55 -    INFO - Going to sleep for [300] seconds...\n</code></pre>"},{"location":"containers/cloudflareddns/#log-levels","title":"Log levels","text":"<p>For <code>LOG_LEVEL</code> you can pick <code>0</code>, <code>1</code>, <code>2</code> or <code>3</code>.</p> <ul> <li> <p><code>0</code> will give no log output. It's not recommended to use.</p> </li> <li> <p><code>1</code> will give you the following output types. It's the recommended value when all things are configured and running as expected.</p> </li> </ul> <pre><code>UPDATE, WARNING, ERROR\n</code></pre> <ul> <li><code>2</code> will give you the following output types. Use this if you always wanna see what's going on, but <code>3</code> gives you too much output.</li> </ul> <pre><code>UPDATE, WARNING, ERROR, INFO\n</code></pre> <ul> <li><code>3</code> will give you the following output types. This is the default.</li> </ul> <pre><code>UPDATE, WARNING, ERROR, INFO, DEBUG\n</code></pre>"},{"location":"containers/cloudflareddns/#json-log","title":"JSON log","text":"<p>Every IP update is also logged to <code>/config/cf-ddns-updates.json</code>. This can be used with the Telegraf JSON parser and the <code>tail</code> input, to get your domain updates into InfluxDB. Example output below.</p> <pre><code>{\"domain\":\"vpn.example.com\",\"recordtype\":\"A\",\"ip\":\"1.1.1.1\",\"timestamp\":\"2020-05-17T20:27:14Z\"}\n{\"domain\":\"vpn.example.com\",\"recordtype\":\"A\",\"ip\":\"1.1.1.1\",\"timestamp\":\"2020-05-17T20:29:26Z\"}\n</code></pre>"},{"location":"containers/cloudflareddns/#cached-results-from-cloudflare","title":"Cached results from Cloudflare","text":"<p>The returned results from Cloudflare are cached. This means minimal api calls to Cloudflare. If you have made any manual changes to the IP on the Cloudflare webinterface, for instance when wanting to test an update, a container restart is needed to clear the cache.</p> <p>The proxy setting (orange cloud) and TTL is also cached and re-set based on the previous value, so if you made any modifications to these settings, you should restart the container so that the script is aware of the new settings.</p>"},{"location":"containers/cloudflareddns/#sending-notifications","title":"Sending notifications","text":"<p>You can send notifications when a DNS record gets updated with a new IP using Apprise. Use the environment variable <code>APPRISE</code> to configure notifications, see below for some examples.</p> <pre><code>-e APPRISE=\"pover://user@token\"\n-e APPRISE=\"pover://user@token;discord://webhook_id/webhook_token\"\n</code></pre>"},{"location":"containers/cloudflareddns/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/doplarr/","title":"hotio/doplarr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/doplarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name doplarr \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/doplarr\n</code></pre> <pre><code>services:\n  doplarr:\n    container_name: doplarr\n    image: ghcr.io/hotio/doplarr\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/doplarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/doplarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/duplicacy/","title":"hotio/duplicacy","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/duplicacy/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name duplicacy \\\n    --hostname duplicacy \\\n    -p 3875:3875 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_cache&gt;:/cache \\\n    -v /&lt;host_folder_logs&gt;:/logs \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/duplicacy\n</code></pre> <pre><code>services:\n  duplicacy:\n    container_name: duplicacy\n    hostname: duplicacy\n    image: ghcr.io/hotio/duplicacy\n    ports:\n      - \"3875:3875\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_cache&gt;:/cache\n      - /&lt;host_folder_logs&gt;:/logs\n      - /&lt;host_folder_data&gt;:/data\n</code></pre> <p>If you don't want to enter your password every time you restart the container, you can set the environment variable <code>DWE_PASSWORD</code> with your password or starting with version 1.4.1 a file <code>/config/keyring</code> will be created that stores your password encryted if you click the checkmark on the login page.</p>"},{"location":"containers/duplicacy/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/duplicacy/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/jackett/","title":"hotio/jackett","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/jackett/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name jackett \\\n    -p 9117:9117 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/jackett\n</code></pre> <pre><code>services:\n  jackett:\n    container_name: jackett\n    image: ghcr.io/hotio/jackett\n    ports:\n      - \"9117:9117\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/jackett/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/jackett/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/jellyfin/","title":"hotio/jellyfin","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/jellyfin/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name jellyfin \\\n    -p 8096:8096 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/jellyfin\n</code></pre> <pre><code>services:\n  jellyfin:\n    container_name: jellyfin\n    image: ghcr.io/hotio/jellyfin\n    ports:\n      - \"8096:8096\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/jellyfin/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/jellyfin/#configuration","title":"Configuration","text":"<p>The following jellyfin path locations are used by default.</p> <pre><code>JELLYFIN_CONFIG_DIR=\"/config\"\nJELLYFIN_DATA_DIR=\"/config/data\"\nJELLYFIN_LOG_DIR=\"/config/log\"\nJELLYFIN_CACHE_DIR=\"/config/cache\"\n</code></pre> <p>You can override these locations by setting them to a different value with a docker environment variable.</p>"},{"location":"containers/jellyfin/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/jellyseerr/","title":"hotio/jellyseerr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/jellyseerr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name jellyseerr \\\n    -p 5055:5055 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/jellyseerr\n</code></pre> <pre><code>services:\n  jellyseerr:\n    container_name: jellyseerr\n    image: ghcr.io/hotio/jellyseerr\n    ports:\n      - \"5055:5055\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/jellyseerr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/jellyseerr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/lidarr/","title":"hotio/lidarr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/lidarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name lidarr \\\n    -p 8686:8686 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/lidarr\n</code></pre> <pre><code>services:\n  lidarr:\n    container_name: lidarr\n    image: ghcr.io/hotio/lidarr\n    ports:\n      - \"8686:8686\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/lidarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/lidarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/mergerfs/","title":"hotio/mergerfs","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/mergerfs/#starting-the-container","title":"Starting the container","text":"cli <pre><code>docker run --rm \\\n    --init \\\n    -v /&lt;host_folder_branch_1&gt;:/branch_1 \\\n    -v /&lt;host_folder_branch_2&gt;:/branch_2 \\\n    -v /&lt;host_folder_mountpoint&gt;:/mountpoint:shared \\\n    --cap-add SYS_ADMIN \\\n    --device /dev/fuse \\\n    ghcr.io/hotio/mergerfs -o allow_other /branch_1:/branch_2 /mountpoint\n</code></pre> <p>The default <code>ENTRYPOINT</code> is <code>mergerfs -f</code>.</p>"},{"location":"containers/mergerfs/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/mergerfs/#using-the-mergerfs-mount-on-the-host","title":"Using the mergerfs mount on the host","text":"<p>By setting the <code>bind-propagation</code> to <code>shared</code> on the volume <code>mountpoint</code>, like this <code>-v /data/mountpoint:/mountpoint:shared</code>, you are able to access the mount from the host. If you want to use this mount in another container, the best solution is to create a volume on the parent folder of that mount with <code>bind-propagation</code> set to <code>slave</code>. For example, <code>-v /data:/data:slave</code> (<code>/data</code> on the host, would contain the previously created volume <code>mountpoint</code>). Doing it like this will ensure that when the container creating the mount restarts, the other containers using that mount will recover and keep working.</p>"},{"location":"containers/mergerfs/#extra-docker-privileges","title":"Extra docker privileges","text":"<p>On some systems you'll also need the following privileges.</p> <pre><code>--security-opt apparmor:unconfined\n</code></pre>"},{"location":"containers/nzbget/","title":"hotio/nzbget","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/nzbget/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name nzbget \\\n    -p 6789:6789 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/nzbget\n</code></pre> <pre><code>services:\n  nzbget:\n    container_name: nzbget\n    image: ghcr.io/hotio/nzbget\n    ports:\n      - \"6789:6789\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/nzbget/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/nzbget/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/nzbhydra2/","title":"hotio/nzbhydra2","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/nzbhydra2/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name nzbhydra2 \\\n    -p 5076:5076 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/nzbhydra2\n</code></pre> <pre><code>services:\n  nzbhydra2:\n    container_name: nzbhydra2\n    image: ghcr.io/hotio/nzbhydra2\n    ports:\n      - \"5076:5076\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/nzbhydra2/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/nzbhydra2/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/overseerr/","title":"hotio/overseerr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/overseerr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name overseerr \\\n    -p 5055:5055 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/overseerr\n</code></pre> <pre><code>services:\n  overseerr:\n    container_name: overseerr\n    image: ghcr.io/hotio/overseerr\n    ports:\n      - \"5055:5055\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/overseerr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/overseerr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/plex/","title":"hotio/plex","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/plex/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name plex \\\n    -p 32400:32400 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e PLEX_CLAIM_TOKEN=\"\" \\\n    -e PLEX_ADVERTISE_URL=\"\" \\\n    -e PLEX_NO_AUTH_NETWORKS=\"\" \\\n    -e PLEX_BETA_INSTALL=\"false\" \\\n    -e PLEX_PURGE_CODECS=\"false\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_transcode&gt;:/transcode \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/plex\n</code></pre> <pre><code>services:\n  plex:\n    container_name: plex\n    image: ghcr.io/hotio/plex\n    ports:\n      - \"32400:32400\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - PLEX_CLAIM_TOKEN\n      - PLEX_ADVERTISE_URL\n      - PLEX_NO_AUTH_NETWORKS\n      - PLEX_BETA_INSTALL=false\n      - PLEX_PURGE_CODECS=false\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_transcode&gt;:/transcode\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/plex/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/plex/#volumes","title":"Volumes","text":"<p>By default the container has 2 volumes defined, the volume <code>/config</code> that contains the configuration files and the volume <code>/transcode</code> which is used as the default transcode directory.</p>"},{"location":"containers/plex/#claim-your-server","title":"Claim your server","text":"<p>When running Plex on a docker <code>bridge</code> network, you can't just get to the webui and start configuring it, you'll need to claim it first. Go to plex.tv/claim and login with your account, copy the claim token and add it to the environment variable like this <code>-e PLEX_CLAIM_TOKEN=\"claim-xxxxxxxxxxxxxxxxxxxx\"</code>. When starting the new plex server for the first time, the server will be added to your account.</p>"},{"location":"containers/plex/#plex-beta","title":"Plex Beta","text":"<p>If you are a Plex Pass subscriber, you can enable the install of beta builds with <code>-e PLEX_BETA_INSTALL=\"true\"</code>. When the container starts, a version check is done for the latest beta and installed if a newer version is found.</p>"},{"location":"containers/plex/#environment-variables-plex_advertise_url-and-plex_no_auth_networks","title":"Environment variables PLEX_ADVERTISE_URL and PLEX_NO_AUTH_NETWORKS","text":"<p>The variables correspond to the below plex network settings.</p> <p></p> <p>The variable <code>PLEX_ADVERTISE_URL</code> is useful to aid your local clients in discovering your plex server when running in the <code>bridge</code> network mode. Most likely you would use something like <code>http://192.168.0.10:32400</code>. You could use <code>PLEX_NO_AUTH_NETWORKS</code> when you're locked out and need to regain access without providing credentials.</p>"},{"location":"containers/plex/#getting-a-token","title":"Getting a token","text":"<p>The following command will interactively ask for your credentials and give you a token. If you don't use 2FA, just press enter.</p> <pre><code>docker run --rm -it --entrypoint=\"\" hotio/plex bash /app/get-token.sh\n</code></pre>"},{"location":"containers/plex/#top-secret-stuff","title":"TOP secret stuff","text":"<p>If you do <code>-e PLEX_BETA_INSTALL=\"https://...\"</code>, stuff happens for which no support will be given.</p>"},{"location":"containers/plex/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/prowlarr/","title":"hotio/prowlarr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/prowlarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name prowlarr \\\n    -p 9696:9696 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/prowlarr\n</code></pre> <pre><code>services:\n  prowlarr:\n    container_name: prowlarr\n    image: ghcr.io/hotio/prowlarr\n    ports:\n      - \"9696:9696\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/prowlarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/prowlarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/qbitmanage/","title":"hotio/qbitmanage","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/qbitmanage/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name qbitmanage \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e ARGS=\"\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/qbitmanage\n</code></pre> <pre><code>services:\n  qbitmanage:\n    container_name: qbitmanage\n    image: ghcr.io/hotio/qbitmanage\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - ARGS\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/qbitmanage/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/qbitmanage/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/qbittorrent/","title":"hotio/qbittorrent","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/qbittorrent/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name qbittorrent \\\n    -p 8080:8080 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e WEBUI_PORTS=\"8080/tcp,8080/udp\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/qbittorrent\n</code></pre> <pre><code>services:\n  qbittorrent:\n    container_name: qbittorrent\n    image: ghcr.io/hotio/qbittorrent\n    ports:\n      - \"8080:8080\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=8080/tcp,8080/udp\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/qbittorrent/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/qbittorrent/#alternative-web-ui","title":"Alternative Web UI","text":"<p>This image comes bundled with the alternative Web UI VueTorrent (<code>/app/vuetorrent</code>) and Nightwalker (<code>/app/nightwalker</code>).</p>"},{"location":"containers/qbittorrent/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/radarr/","title":"hotio/radarr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/radarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name radarr \\\n    -p 7878:7878 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/radarr\n</code></pre> <pre><code>services:\n  radarr:\n    container_name: radarr\n    image: ghcr.io/hotio/radarr\n    ports:\n      - \"7878:7878\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/radarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/radarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/readarr/","title":"hotio/readarr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/readarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name readarr \\\n    -p 8787:8787 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/readarr\n</code></pre> <pre><code>services:\n  readarr:\n    container_name: readarr\n    image: ghcr.io/hotio/readarr\n    ports:\n      - \"8787:8787\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/readarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/readarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/requestrr/","title":"hotio/requestrr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/requestrr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name requestrr \\\n    -p 4545:4545 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/requestrr\n</code></pre> <pre><code>services:\n  requestrr:\n    container_name: requestrr\n    image: ghcr.io/hotio/requestrr\n    ports:\n      - \"4545:4545\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/requestrr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/requestrr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/rflood/","title":"hotio/rflood","text":"<p> GitHub docker.io /   ghcr.io</p> <p>What is this?</p> <p>A docker image with rTorrent and the Flood UI, also optional WireGuard VPN support.</p>"},{"location":"containers/rflood/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name rflood \\\n    -p 3000:3000 \\\n    -p 5000:5000 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e FLOOD_AUTH=\"false\" \\\n    -e ARGS=\"\" \\\n    -e FLOOD_ARGS=\"\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/rflood\n</code></pre> <pre><code>services:\n  rflood:\n    container_name: rflood\n    image: ghcr.io/hotio/rflood\n    ports:\n      - \"3000:3000\"\n      - \"5000:5000\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - FLOOD_AUTH=false\n      - ARGS\n      - FLOOD_ARGS\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/rflood/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/rflood/#changing-the-webui-port","title":"Changing the WebUI port","text":"<p>Under certain circumstances it's required to run the WebUI on a different internal port, you can do that by modifying the environment variable <code>WEBUI_PORTS</code> accordingly. It should be in the format <code>xxxx/tcp,xxxx/udp</code>, take a look at the default with <code>docker logs</code> (variable is printed at container start) or <code>docker inspect</code>.</p>"},{"location":"containers/rflood/#xml-rpc-json-rpc","title":"XML-RPC / JSON-RPC","text":"<p>On port <code>5000</code> runs Nginx exposing the <code>/RPC2</code>, <code>/JSONRPC</code> and <code>/RPC</code> endpoints. Default credentials are shown on first start in the log output, <code>localhost</code> doesn't need credentials (xmlrpc tool is included). To reset the password, remove or modify <code>/config/rpc2/basic_auth_credentials</code>.</p> <pre><code>/RPC2    &gt;&gt; header 'Content-Type' forced to 'text/xml'\n/JSONRPC &gt;&gt; header 'Content-Type' forced to 'application/json-rpc'\n/RPC     &gt;&gt; header 'Content-Type' not modified\n</code></pre>"},{"location":"containers/rflood/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/sabnzbd/","title":"hotio/sabnzbd","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/sabnzbd/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name sabnzbd \\\n    -p 8080:8080 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e WEBUI_PORTS=\"8080/tcp,8080/udp\" \\\n    -e ARGS=\"\" \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/sabnzbd\n</code></pre> <pre><code>services:\n  sabnzbd:\n    container_name: sabnzbd\n    image: ghcr.io/hotio/sabnzbd\n    ports:\n      - \"8080:8080\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=8080/tcp,8080/udp\n      - ARGS\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/sabnzbd/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/sabnzbd/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/sonarr/","title":"hotio/sonarr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/sonarr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name sonarr \\\n    -p 8989:8989 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/sonarr\n</code></pre> <pre><code>services:\n  sonarr:\n    container_name: sonarr\n    image: ghcr.io/hotio/sonarr\n    ports:\n      - \"8989:8989\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/sonarr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/sonarr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/stash/","title":"hotio/stash","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/stash/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name stash \\\n    -p 9999:9999 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/stash\n</code></pre> <pre><code>services:\n  stash:\n    container_name: stash\n    image: ghcr.io/hotio/stash\n    ports:\n      - \"9999:9999\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/stash/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/stash/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/tautulli/","title":"hotio/tautulli","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/tautulli/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name tautulli \\\n    -p 8181:8181 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -e WEBUI_PORTS=\"8181/tcp,8181/udp\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    ghcr.io/hotio/tautulli\n</code></pre> <pre><code>services:\n  tautulli:\n    container_name: tautulli\n    image: ghcr.io/hotio/tautulli\n    ports:\n      - \"8181:8181\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n      - WEBUI_PORTS=8181/tcp,8181/udp\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n</code></pre>"},{"location":"containers/tautulli/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/tautulli/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/unpackerr/","title":"hotio/unpackerr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/unpackerr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name unpackerr \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/unpackerr\n</code></pre> <pre><code>services:\n  unpackerr:\n    container_name: unpackerr\n    image: ghcr.io/hotio/unpackerr\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/unpackerr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/unpackerr/#configuration","title":"Configuration","text":"<p>You can use docker environment variables or a configuration file that should be stored in <code>/config/unpackerr.conf</code>. Take a look at the upstream project page for info on how to configure Unpackerr.</p>"},{"location":"containers/unpackerr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"containers/whisparr/","title":"hotio/whisparr","text":"<p> GitHub docker.io /   ghcr.io</p>"},{"location":"containers/whisparr/#starting-the-container","title":"Starting the container","text":"clicompose <pre><code>docker run --rm \\\n    --name whisparr \\\n    -p 6969:6969 \\\n    -e PUID=1000 \\\n    -e PGID=1000 \\\n    -e UMASK=002 \\\n    -e TZ=\"Etc/UTC\" \\\n    -v /&lt;host_folder_config&gt;:/config \\\n    -v /&lt;host_folder_data&gt;:/data \\\n    ghcr.io/hotio/whisparr\n</code></pre> <pre><code>services:\n  whisparr:\n    container_name: whisparr\n    image: ghcr.io/hotio/whisparr\n    ports:\n      - \"6969:6969\"\n    environment:\n      - PUID=1000\n      - PGID=1000\n      - UMASK=002\n      - TZ=Etc/UTC\n    volumes:\n      - /&lt;host_folder_config&gt;:/config\n      - /&lt;host_folder_data&gt;:/data\n</code></pre>"},{"location":"containers/whisparr/#tags","title":"Tags","text":"Tags Description Last Updated Age"},{"location":"containers/whisparr/#wireguard","title":"WireGuard","text":"<p>Info</p> <p>This image includes VPN support. The cli/compose examples below are environment variables and settings complementary to the app image examples, this means you'll have to add/merge the stuff below with the stuff above. In case you are still in need of a VPN, consider using my affiliate link for Proton, Private Internet Access or TorGuard (50% Off: <code>hotio.dev-50-all</code>).</p> <p> </p> genericprotonpia clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"generic\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"false\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=generic #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=false #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"proton\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=proton #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> clicompose <pre><code>docker run --rm \\\n    --hostname container-name.internal \\ #(18)\n    -e VPN_ENABLED=\"true\" \\ #(5)\n    -e VPN_CONF=\"wg0\" \\ # READ THIS(8)\n    -e VPN_PROVIDER=\"pia\" \\ #(4)\n    -e VPN_LAN_NETWORK=\"192.168.1.0/24\" \\ #(1)\n    -e VPN_LAN_LEAK_ENABLED=\"false\" \\\n    -e VPN_EXPOSE_PORTS_ON_LAN=\"\" \\ #(2)\n    -e VPN_AUTO_PORT_FORWARD=\"true\" \\ #(6)\n    -e VPN_AUTO_PORT_FORWARD_TO_PORTS=\"\" \\ #(15)\n    -e VPN_KEEP_LOCAL_DNS=\"false\" \\ #(10)\n    -e VPN_FIREWALL_TYPE=\"auto\" \\ #(17)\n    -e VPN_HEALTHCHECK_ENABLED=\"false\" \\\n    -e VPN_PIA_USER=\"\" \\ #(11)\n    -e VPN_PIA_PASS=\"\" \\\n    -e VPN_PIA_PREFERRED_REGION=\"\" \\ #(7)\n    -e VPN_PIA_DIP_TOKEN=\"no\" \\ #(13)\n    -e VPN_PIA_PORT_FORWARD_PERSIST=\"false\" \\ #(14)\n    -e PRIVOXY_ENABLED=\"false\" \\\n    -e UNBOUND_ENABLED=\"false\" \\ #(16)\n    --cap-add=NET_ADMIN \\\n    --sysctl=\"net.ipv4.conf.all.src_valid_mark=1\" \\ #(12)\n    --sysctl=\"net.ipv6.conf.all.disable_ipv6=1\" \\ #(3)\n    --device /dev/net/tun:/dev/net/tun \\ # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol> <pre><code>services:\n  app:\n    hostname: container-name.internal #(18)\n    environment:\n      - VPN_ENABLED=true #(5)\n      - VPN_CONF=wg0 # READ THIS(8)\n      - VPN_PROVIDER=pia #(4)\n      - VPN_LAN_NETWORK=192.168.1.0/24 #(1)\n      - VPN_LAN_LEAK_ENABLED=false\n      - VPN_EXPOSE_PORTS_ON_LAN #(2)\n      - VPN_AUTO_PORT_FORWARD=true #(6)\n      - VPN_AUTO_PORT_FORWARD_TO_PORTS= #(15)\n      - VPN_KEEP_LOCAL_DNS=false #(10)\n      - VPN_FIREWALL_TYPE=auto #(17)\n      - VPN_HEALTHCHECK_ENABLED=false\n      - VPN_PIA_USER #(11)\n      - VPN_PIA_PASS\n      - VPN_PIA_PREFERRED_REGION #(7)\n      - VPN_PIA_DIP_TOKEN=no #(13)\n      - VPN_PIA_PORT_FORWARD_PERSIST=false #(14)\n      - PRIVOXY_ENABLED=false\n      - UNBOUND_ENABLED=false #(16)\n    cap_add:\n      - NET_ADMIN\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1 #(12)\n      - net.ipv6.conf.all.disable_ipv6=1 #(3)\n    devices:\n      - /dev/net/tun:/dev/net/tun # OPTIONAL, READ THIS(9)\n    ...\n</code></pre> <ol> <li> <p>The environment variable <code>VPN_LAN_NETWORK</code> can be set to for example <code>192.168.1.0/24</code>, <code>192.168.1.0/24,192.168.44.0/24</code> or <code>192.168.1.33</code>, so you can get access to the webui or other additional ports (see below). If for example you were to pick <code>192.168.0.0/24</code>, every device with an ip in the range <code>192.168.0.0 - 192.168.0.255</code> on your LAN is allowed access to the webui.</p> </li> <li> <p>If you need to expose ports on your LAN you can use <code>VPN_EXPOSE_PORTS_ON_LAN</code>. For example <code>VPN_EXPOSE_PORTS_ON_LAN=7878/tcp,9117/tcp</code>, will block those ports on the vpn interface, so that there's no risk that they might be exposed to the world and allow access to them from your LAN. Some images also have a <code>WEBUI_PORTS</code> environment variable that does basically the same for the vpn part. For those apps that support it, it'll also change the port on which the app runs.</p> </li> <li> <p>With <code>net.ipv6.conf.all.disable_ipv6=1</code> all ipv6 support is disabled. Leave ipv6 disabled and remove all references to it in your <code>wg0.conf</code> file to keep things simple. If you need any sort of ipv6 support, enable it with <code>net.ipv6.conf.all.disable_ipv6=0</code>. A WireGuard ipv6 endpoint is currently not supported.</p> </li> <li> <p>Possible values are <code>generic</code>, <code>proton</code> and <code>pia</code>.</p> </li> <li> <p>There needs to be a file <code>wg0.conf</code> located in <code>/config/wireguard</code> and you need to set the variable <code>VPN_ENABLED</code> to <code>true</code> for the VPN to start. If you'd like to execute some of your own bash commands you can place two scripts alongside your <code>wg0.conf</code>, called <code>wg0-pre.sh</code> and <code>wg0-post.sh</code>. These will execute right before the check for the existence of a <code>wg0.conf</code> file and almost at the end, right before the internet connectivity test.</p> </li> <li> <p>Auto retrieve a forwarded port and configure the supported app if set to <code>true</code> or if you can manually request/set a forwarded port in the VPN provider's web interface, fill in the port number (just the number). Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>By default a random server is used, but if you prefer a certain region you can fill in the region id. A list of available regions can be found in <code>/config/wireguard</code> after the first start. If you're seeing an error message <code>shuf: getrandom: Function not implemented</code>, you can't let it pick one randomly and are forced to fill in a region id.</p> </li> <li> <p>With <code>VPN_CONF</code> you can set the name used for your WireGuard config. This is an example of how your <code>wg0.conf</code> file should look like. If there's a lot of extra stuff, remove it unless you know what it's there for. The WireGuard config is automatically modified to use <code>AllowedIPs = 0.0.0.0/1,128.0.0.0/1</code> for compatibility with Synology/QNAP/Asustor/WSL2 systems if you append <code>-fix</code>, so <code>VPN_CONF=wg0-fix</code>. WSL2 users can also compile their own kernel if they don't wanna use this workaround. <pre><code>[Interface]\nPrivateKey = supersecretprivatekey\nAddress = xx.xx.xxx.xxx/32 # Yes, /32\nDNS = x.x.x.x\n\n[Peer]\nPublicKey = publickey\nAllowedIPs = 0.0.0.0/0\nEndpoint = xxx.x.xxx.x:51820\n</code></pre></p> </li> <li> <p>If the WireGuard kernel module is missing (most likely on Synology/QNAP/Asustor), you can run WireGuard in userspace thanks to <code>wireguard-go</code>. For that you'll need to add the device <code>/dev/net/tun</code>. It's most likely that the device <code>/dev/net/tun</code> does not exist however, have a read here for instructions on checking and adding the device.</p> </li> <li> <p>Setting this to <code>true</code> will re-add the default nameserver if it's been overwritten by the <code>DNS = ...</code> entry in <code>wgO.conf</code>. This should keep container name resolution working. If container name resolution still doesn't work, add <code>--dns 1.1.1.1</code>, somehow this can fix it (confirmed on MacOS).</p> </li> <li> <p>When using <code>VPN_PROVIDER=pia</code>, fill in your username and password. A <code>wg0.conf</code> will be automatically downloaded.</p> </li> <li> <p>Required in most cases, on some systems that don't have <code>rp_filter</code> set to strict, it's optional.</p> </li> <li> <p>Fill in your DIP token here, if you've bought the dedicated ip option.</p> </li> <li> <p>If you'd like to keep using the same forwarded port until it expires, set this to <code>true</code>.</p> </li> <li> <p>Adds a redirect for the forwarded port from your vpn provider to the internal port on which the app runs, ports in this list are also not blocked on the wireguard interface, so this var is also useful if you want to expose a port on both your LAN and VPN. Values like <code>32400/tcp</code> will use the port from <code>VPN_AUTO_PORT_FORWARD</code> to create the redirect or if set to <code>true</code> the forwarded port from pia/proton. Use <code>3000@3001/tcp,3002@3003/tcp</code> syntax for extra static redirects. The only known usecase as of right now is Plex and exposing it on the VPN with a non configurable forwarded port, because it's not possible to run Plex on anything else but 32400. Useful website to check for open ports is YouGetSignal and ipleak.net to leak test with <code>.torrent</code> file.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> <li> <p>Possible values are <code>auto</code>, <code>legacy</code> or <code>nftables</code>. The default is <code>auto</code>, this will try to use the most modern method available. If this doesn't work, you can try forcing it to <code>legacy</code> or <code>nftables</code>.</p> </li> <li> <p>When enabling the Unbound DNS server your requests will use DNS over TLS to Cloudflare. Except for requests made to <code>.internal</code> and <code>.vpn</code> TLDs, those are done to the local docker DNS server on 127.0.0.11. So if you want to use container hostnames to connect to other containers within a bridge network, you'll have to use <code>--hostname</code> and use <code>container-name.internal</code> or <code>container-name.vpn</code>. Currently <code>.vpn</code> is a non existing TLD, but that can change in the future. The TLD <code>.internal</code> should become the standard for internal networks, so it's the safest choice. Unbound can be used regardless of <code>VPN_ENABLED</code> being <code>true</code> or <code>false</code>.</p> </li> </ol>"},{"location":"guides/torguard/","title":"TorGuard","text":"<p>Affiliate Info</p> <p>Affiliate link for TorGuard. Get a 50% discount, with code: <code>hotio.dev-50-all</code>.</p> <p> </p> <p>Here are the required steps we need to take in order to get a WireGuard <code>conf</code> file with port forwarding enabled.</p>"},{"location":"guides/torguard/#changing-service-credentials","title":"Changing Service Credentials","text":"<p>First we're going to change the default credentials under Manage Credentials. This step is optional though if you've already done it or wish to keep using the defaults.</p> <p></p> <p>Hit <code>Generate Random Login</code>. After it's done, save the credentials. We'll need them soon.</p> <p></p>"},{"location":"guides/torguard/#config-generator","title":"Config Generator","text":"<p>We'll generate a new WireGuard config on the Config Generator page. Fill in the details like shown below, use your own server preference.</p> <p></p> <p>Hit <code>Generate Config</code>. You'll get your config as seen below.</p> <p></p>"},{"location":"guides/torguard/#test-wireguard-config","title":"Test WireGuard Config","text":"<p>You can now use your created <code>conf</code> file and add it to the VPN image per the instructions. When executing the image and all went well you'll see:</p> <pre><code>[INF] [2024-03-12 07:29:51] [VPN] Performing internet connectivity test...\n[INF] [2024-03-12 07:29:51] [VPN] [IPV4] [PING: 25.167 ms] [Amsterdam, NH, The Netherlands] [UK-2 Limited] [206.217.216.28]\n</code></pre> <p>You can skip this step if you want, because later on we'll have to re-generate our <code>conf</code> file anyway. The ip we'll need later on is the WireGuard endpoint ip.</p>"},{"location":"guides/torguard/#port-forwarding","title":"Port Forwarding","text":"<p>Next we'll be getting a forwarded port. Go to <code>Services &gt; My Services</code>.</p> <p></p> <p>Then <code>Manage &gt; Port Forward Request</code>.</p> <p></p> <p>You'll see the below page, fill in the form as shown. You can pick your own port of choice. The ip is the same as shown above in our test <code>206.217.216.28</code>, usually also the same as our WireGuard endpoint.</p> <p></p> <p>Hit <code>Submit Request</code>. You'll see the following output if you scroll down.</p> <p></p>"},{"location":"guides/torguard/#re-generate-wireguard-config","title":"Re-Generate WireGuard Config","text":"<p>After having requested the port forward, we'll have to re-generate our config. Go to the Config Generator and make sure it's set like below.</p> <p></p> <p>Hit <code>Generate Config</code>. Start the VPN image with the updated <code>conf</code> file and do a port check on YouGetSignal. You'll see that our port is open and ready to receive traffic.</p> <p></p>"},{"location":"scripts/arr-discord-notifier/","title":"Arr Discord Notifier","text":"<p>Announcement</p> <p>Both Sonarr and Radarr now come with built-in Discord notifications based on this script, so it's no longer bundled with those images. The script still works though if you prefer to use it.</p> <p> GitHub </p> <p>Arr Discord Notifier sends pretty notifications to a discord webhook. The Radarr and Sonarr v3 (only v3 is supported) docker images come bundled with this script, but it can also be used on its own.</p>"},{"location":"scripts/arr-discord-notifier/#configuration","title":"Configuration","text":"<p>Add a <code>Custom Script</code> to the <code>Connect</code> settings in Sonarr/Radarr as seen below.  </p> <p></p> <p>Then add the environment variable <code>DISCORD_WEBHOOK</code> with your webhook url provided by Discord to the container. After that hit the <code>Test</code> button and you should see a notification appear in your discord channel.  </p> <p>If you also configure the environment variable <code>TMDB_API_KEY</code>, when possible it will use an episode still as a backdrop image and add a <code>Cast</code> field.</p> <p>If you want to hide some fields, you can use <code>DROP_FIELDS=\"backdrop overview release airdate\"</code> as a variable, all field names in lowercase, <code>backdrop</code> and <code>poster</code> are valid values too.</p> <p>Sending to multiple webhooks can be done with additional variables like <code>DISCORD_WEBHOOK_0</code> and <code>DROP_FIELDS_0</code>.</p> <p>By default the hostname is used as the Author of the notification, you can modify this by changing the hostname or the variable <code>AUTHOR_NAME</code>.</p>"},{"location":"scripts/arr-discord-notifier/#sample-images","title":"Sample images","text":""},{"location":"scripts/pullio/","title":"Pullio","text":"<p> GitHub </p> <p>Updating your docker containers the easy way.</p> <p>Pullio is a bash script that you execute with cron, a systemd timer or any other way that you prefer. It then does a <code>docker compose pull</code> for all the containers configured to have notifications or updates enabled. It then checks if there's an update available and takes action according to your configuration. As you might have already guessed it, this script relies on <code>docker compose</code> to do the heavy lifting and thus is only compatible with <code>docker compose</code> managed containers.</p> <p>Features:</p> <ul> <li>Discord notifications (see below for preview)</li> <li>No notifications if you leave the webhook out, it'll run as an updater and script executer</li> <li>Detailed info about what has changed for images that follow the Opencontainers Annotation Keys</li> <li>Execute script before sending notification</li> <li>Execute script before updating container, after container is stopped</li> <li>Private registries</li> <li>With <code>--tag</code> you can use seperate configs for hourly \"Update available\" notifications and on a daily schedule actually apply the updates</li> </ul>"},{"location":"scripts/pullio/#installation","title":"Installation","text":"<pre><code>sudo curl -fsSL \"https://raw.githubusercontent.com/hotio/pullio/master/pullio.sh\" -o /usr/local/bin/pullio\nsudo chmod +x /usr/local/bin/pullio\n</code></pre> <p>Now execute it however and whenever you want.</p>"},{"location":"scripts/pullio/#configuration","title":"Configuration","text":"<p>You configure the script its behaviour by adding one or more of the following labels to your <code>compose.yaml</code> for every container you want. Adding no discord webhook will disable the notifications.</p> <pre><code>...\nlabels:\n  - \"org.hotio.pullio.notify=true\"\n  - \"org.hotio.pullio.update=true\"\n  - \"org.hotio.pullio.discord.webhook=https://discord.com/api/webhooks/...\"\n  - \"org.hotio.pullio.generic.webhook=https://some.domain.com/api/webhooks/...\"\n  - \"org.hotio.pullio.author.avatar=https://domain.com/logo.png\"\n  - \"org.hotio.pullio.script.notify=bash /notify-script.sh\"\n  - \"org.hotio.pullio.script.update=bash /update-script.sh\"\n  - \"org.hotio.pullio.registry.authfile=/authfile.txt\"\n</code></pre> <p>Using <code>--tag mytag</code>, would let you do the following.</p> <pre><code>...\nlabels:\n  - \"org.hotio.pullio.mytag.notify=true\"\n  - \"org.hotio.pullio.mytag.discord.webhook=https://discord.com/api/webhooks/...\"\n</code></pre> <p>If you need to provide credentials for a Private Registry, this file's content needs to be as shown below.</p> <pre><code>{\n  \"registry\": \"ghcr.io\",\n  \"username\": \"your_username\",\n  \"password\": \"your_password\"\n}\n</code></pre> <p>Info</p> <p>Don't forget to do <code>cd /path/of/compose/file</code> and <code>docker compose up -d</code> after adding the labels. The use of <code>-f</code> is not supported.</p>"},{"location":"scripts/pullio/#troubleshooting","title":"Troubleshooting","text":"<p>It can be frustrating to test the script if no docker image updates are available, for that you can do <code>./pullio.sh --debug</code> and the script will behave as if an update is available.</p>"},{"location":"scripts/pullio/#notification-preview","title":"Notification preview","text":""},{"location":"scripts/sysinfo/","title":"SysInfo","text":"<p> GitHub </p> <p>Get a quick system overview from the terminal, an ideal replacement for web based dashboards.</p> <p>Features:</p> <ul> <li><code>system info</code>, basic info about your system like uptime and load, on <code>apt-get</code> based systems it'll also show amount of available updates</li> <li><code>ip addresses</code>, all the global ip addresses easily viewable</li> <li><code>thermals</code>, get a few temperatures from the kernel provided thermal zones</li> <li><code>ups info</code>, the important stuff you need to know about your NUT supported UPS</li> <li><code>docker</code>, see how your docker containers are doing</li> <li><code>virtual machines</code>, keep an eye on which vm is running</li> <li><code>systemd services</code>, services added in the config will show up</li> <li><code>smb shares</code>, what folder is exported and who has access, you can see it here</li> <li><code>network traffic</code>, if vnstat is available, you can see it here</li> <li><code>memory usage</code>, see your usage before your system experiences a OOM failure</li> <li><code>disk space usage</code>, the same as with memory, but for disk space</li> <li><code>physical drives</code>, spot drive health before it's too late</li> </ul>"},{"location":"scripts/sysinfo/#installation","title":"Installation","text":"<pre><code>sudo curl -fsSL \"https://raw.githubusercontent.com/hotio/sysinfo.sh/master/sysinfo.sh\" -o /usr/local/bin/sysinfo\nsudo chmod +x /usr/local/bin/sysinfo\n</code></pre>"},{"location":"scripts/sysinfo/#config","title":"Config","text":"<p>Check the script's content for the config section and available settings. Any of those settings can also be placed in a file <code>/etc/default/hotio-sysinfo</code> to allow for script updates without losing the config.</p>"},{"location":"scripts/sysinfo/#execution","title":"Execution","text":"<p>Now execute <code>sysinfo --help</code> to see all available options, which you can combine to show what you want or just <code>sysinfo</code> to show everything. Some options require <code>sudo</code> or <code>root</code>.</p>"},{"location":"scripts/sysinfo/#preview","title":"Preview","text":""}]}